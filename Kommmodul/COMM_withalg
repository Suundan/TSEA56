/*
* COMM.c
*
* Created: 4/19/2016 10:39:58 AM
*  Author: sankl660
*/

#define F_CPU 1842000UL
#include <avr/io.h>
#include <util/twi.h>
#include <avr/delay.h>
#include <avr/interrupt.h>

volatile unsigned int recieved_data = 0;
volatile uint16_t US_sens_front_left = 0x0;
volatile uint16_t US_sens_back_left = 0x0;
volatile uint8_t IR_sens_left = 0x0;
volatile uint8_t IR_sens_right = 0x0;
volatile uint8_t IR_sens_front = 0x0;
volatile uint8_t Gyro_sens = 0x0;
volatile uint16_t Photo_distance = 0x0;
volatile uint8_t IR_detector = 0x0;
volatile int dataRecieved = 0;
int falesafecounter = 0;

volatile int wheelRad = 3;
const int numOfWheelSectors = 4;

volatile float refDist = 0;
volatile float traveledDistTot = 0;

static const int mapRows = 17;
static const int mapCols = 31;
volatile char mapArray[17][31];

volatile int roboPos[2];

volatile signed int rowDir;
volatile signed int colDir;

//Interrupt from firefly
ISR(USART_RXC_vect) {
	
	PORTA = 0x01;
	PORTA = 0x00;
	//Send data to buss
	cli();
	TWITransmitData(UDR);
	sei();
	
	PORTA = 0x02;
	PORTA = 0x00;
}

//Interrupt from TWI-bus
ISR(TWI_vect){
	PORTA = 0x02;
	PORTA = 0x00;
	
	cli();
	
	//Ready to recieve data
	TWCR = (0<<TWIE)|(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
	//Wait for data
	while(!(TWCR & (1<<TWINT)));
	
	//Maybe check if status register is correct?
	
	//Call recieve function
	TWIRecieveFromSens();
	
	sei();
	
	PORTA = 0x01;
	PORTA = 0x00;
}

//Bluetooth config
void init_bluetooth()
{
	// Set TXD (port1) as out, 0b00000010
	DDRD = (1<<PORTD1);
	
	//Config of baudrate
	UBRRH = 0x00; //(unsigned char)(ubrr>>8);
	UBRRL = 0x00; //(unsigned char)ubrr;
	
	// Enable send, receive and interrupt
	UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE);

	// Data format: 8data, 1stop bit ligger som standard
	UCSRC = (1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1);
}

//Bus config
void TWIInit(void) {
	
	//Global interrupt enable
	sei();
	
	//Set SCL speed
	TWSR = (0<<TWPS0)|(0<<TWPS1); //Prescaler value
	TWBR = 0x0C;  //Bit rate registry to 12
	
	// Enable bus, ackbit and interrupt
	TWCR = (1<<TWEN)|(1<<TWEA)|(1<<TWIE);
	
	//Slavadress (sista ska vara ett för att enabla general call)
	//Kommmudul: 0x11
	//Sensormodul: 0x21
	//Styrmodul: 0x41
	
	//Set slave address
	TWAR = 0x11;
}

//Map initializing
void mapInit(void){
	for(int i = 0; i < mapRows; i++){
		for (int j = 0; j < mapCols; j++)
		{
			mapArray[i][j] = 'u';
		}
	}
	
	mapArray[17][16] = 'o';
	mapArray[16][16] = 'o';
	mapArray[17][15] = 'w';
	mapArray[17][17] = 'w';
	
	roboPos[1] = 17;
	roboPos[2] = 16;
	
	rowDir = -1;
	colDir = 0;
}

//Transmit 8-bit data through bluetooth
void bluetooth_transmit(uint8_t data)
{
	// Wait for empty buffer
	while ( !( UCSRA & (1<<UDRE)) );
	
	// Save data to buffer and send
	UDR = data;
}

//Send start condition
void TWIStart(void) {
	TWCR = (1<<TWSTA)|(1<<TWINT)|(0<<TWIE)|(1<<TWEN); //Skickar startbit, sätter avbrottsflaggan, avaktiverar avbrott, aktiverar bussen
	while (!(TWCR & (1<<TWINT)));  //Väntar på att start-signalen ska skickas iväg ifall bussen är upptagen t.ex.
}

//Send stop condition
void TWIStop(void) {
	TWCR = (1<<TWSTO)|(1<<TWINT)|(1<<TWIE)|(1<<TWEN)|(1<<TWEA); //Skickar stoppbit, sätter avbrottsflaggan, aktiverar avbrott, aktiverar bussen, aktiverar ackflaggan
}

//Send 8-bit data to bus
void TWITransmitData(uint8_t data) {
	
	PORTA = 0x01;
	PORTA = 0x00;
	
	//Send start condition
	TWIStart();
	
	PORTA = 0x02;
	PORTA = 0x00;
	
	//Check if start is sent
	if (!((TWSR & 0xF8) == 0x08 || (TWSR & 0xF8) == 0x10));
	
	//Send slave address
	TWISend(0x40);
	
	//Check if not right
	if((TWSR & 0xF8) != 0x18) {
		
		//Check if arbitration is lost
		if ((TWSR & 0xF8) == 0x38) {
			TWIStop(); //release bus control
			return;
		}
		
		//"not ack" received
		if ((TWSR & 0xF8) == 0x20) {
			
			//Eventuellt fatal error badness 1000000000
			//Kanske inte behöver skicka ett stoppvilkor utan att det räcker att skicka ett repeated start och hantera det i styr...
			TWIStop(); //release bus control
			TWITransmitData(data); //Resend
			return;
		}
	}
	
	//Send header, own address + info
	TWISend(0x10);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28); //handle "not ack" received something very wrong has happened
	
	//send data
	TWISend(data);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28); //handle "not ack" received something very wrong has happened
	
	//Send stop condition
	TWIStop();
}

//Send the data
void TWISend(uint8_t data) {
	TWDR = data; //Save data to register
	TWCR = (0<<TWSTA)|(1<<TWINT)|(1<<TWEN); //Send data
	while (!(TWCR & (1<<TWINT))); //Wait for "ack"-bit
}

//Receive 16 bit data
uint16_t Recieve16Data(void) {
	
	//Ready to receive next data
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
	//Wait for data
	while(!(TWCR & (1<<TWINT)));
	
	// if "not ack" received, do something
	if ((TWSR & 0xF8) != 0x90);

	//Save msb data to int
	uint16_t data_16 = (TWDR << 8);
	
	//Ready to receive next data
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
	//Wait for data
	while(!(TWCR & (1<<TWINT)));
	
	// if "not ack" received, do something
	if ((TWSR & 0xF8) != 0x90);
	
	//Save lsb data to int
	data_16 |= TWDR;
	return data_16;
}

//Receive 8 bit data
uint8_t Recieve8Data(void) {
	
	//Ready to receive next data
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
	//Wait for data
	while(!(TWCR & (1<<TWINT)));
	
	// if "not ack" received, do something
	if ((TWSR & 0xF8) != 0x90);

	return TWDR;
}

//Receive sensor data
void TWIRecieveFromSens(void) {
	
	//Get the values from the bus
	US_sens_front_left = Recieve16Data();
	US_sens_back_left = Recieve16Data();
	IR_sens_left = Recieve8Data();
	IR_sens_right = Recieve8Data();
	IR_sens_front = Recieve8Data();
	Gyro_sens = Recieve8Data();
	Photo_distance = Recieve16Data();
	IR_detector = Recieve8Data();
	
	//Ready to recieve stop condition
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
	//Wait for stop condition
	while(!(TWCR & (1<<TWINT)));
	
	//if not a stop condition
	if ((TWSR & 0xF8) != 0xA0);
	
	//Release bus control
	TWCR = (1<<TWIE)|(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
}

//Send sensor data to PC
void sendSensorData(void) {
	bluetooth_transmit('s');
	bluetooth_transmit(US_sens_front_left >> 8);
	bluetooth_transmit(US_sens_front_left & 0xFF);
	
	bluetooth_transmit(US_sens_back_left >> 8);
	bluetooth_transmit(US_sens_back_left & 0xFF);
	
	bluetooth_transmit(IR_sens_left);
	bluetooth_transmit(IR_sens_right);
	bluetooth_transmit(IR_sens_front);
	
	bluetooth_transmit(Gyro_sens);
	
	bluetooth_transmit(Photo_distance >> 8);
	bluetooth_transmit(Photo_distance & 0xFF);
	
	bluetooth_transmit(IR_detector);
}

//Send map to PC
void sendMap(char map[mapRows][mapCols]){
	
	char tmp = mapArray[roboPos[1]][roboPos[2]];
	
	mapArray[roboPos[1]][roboPos[2]] = 'p';
	
	bluetooth_transmit('m');
	
	for(int i = 0; i < mapRows; i++){
		for (int j = 0; j < mapCols; j++)
		{
			bluetooth_transmit(map[i][j]);
		}
	}
	
	mapArray[roboPos[1]][roboPos[2]] = tmp;
}

//Go forward, adjusting to wall
void goForward(){
	//Go forward, adjust to wall
	TWITransmitData('p');
}

//Turns 90 degrees left
void turnLeft(){
	//Turn left, 90 degrees
	TWITransmitData('s');
	
	//Update direction
	if (rowDir != 0)
	{
		colDir = rowDir;
		rowDir = 0;
	}
	else
	{
		rowDir = - colDir;
		colDir = 0;
	}
}

//Turns 90 degrees right
void turnRight(){
	//Turn right, 90 degrees
	TWITransmitData('k');
	
	//Update direction
	if (rowDir != 0)
	{
		colDir = - rowDir;
		rowDir = 0;
	}
	else
	{
		rowDir = colDir;
		colDir = 0;
	}
}

//Checks if robot has been to the left
int leftIsFree(int coords[2]){
	if (US_sens_front_left > 0x085C)
	{
		if (mapArray[coords] == 'u')
		{
			mapArray[coords] = 'o';
			return 1;
		}
	}
	if (mapArray[coords] == 'u')
	{
		mapArray[coords] = 'w';
	}
	return 0;
}

//Checks if robot has been to the front
int frontIsFree(){
	if (IR_sens_front > 0x085C)
	{
		if ( mapArray[coords] == 'u')
		{
			mapArray[coords] = 'o';
			return 1;
		}
	}
	if (mapArray[coords] == 'u')
	{
		mapArray[coords] = 'w';
	}
	return = 0;
}

//Checks if robot has been to the right
int rightIsFree(int coords[2]){
	if (IR_sens_right > 0x085C)
	{
		if ( mapArray[coords] == 'u')
		{
			mapArray[coords] = 'o';
			return 1;
		}
	}
	if (mapArray[coords] == 'u')
	{
		mapArray[coords] = 'w';
	}
	return 0;
}

//Finds the coordinates adjacent to the YI-Bot
//in order: to the left of, front of, to the right of
void findAdjCoords(int *leftCoords[2], int *frontCoords[2], int *rightCoords[2])
{
	//TODO check if locally defined pointers need to be freed
	//TODO make sure this code works
	if (rowDir == 1)
	{
		*leftCoords = {roboPos[1],roboPos[2]+1};
		*frontCoords = {roboPos[1]+1,roboPos[2]};
		*rightCoords = {roboPos[1], roboPos[2]-1}
	}
	else if (rowDir == -1)
	{
		*leftCoords = {roboPos[1],roboPos[2]-1};
		*frontCoords = {roboPos[1]-1,roboPos[2]};
		*rightCoords = {roboPos[1], roboPos[2]+1}
	}
	else if (colDir == 1)
	{
		*leftCoords = {roboPos[1]-1,roboPos[2]};
		*frontCoords = {roboPos[1],roboPos[2]+1};
		*rightCoords = {roboPos[1]+1, roboPos[2]}
	}
	else
	{
		*leftCoords = {roboPos[1]+1,roboPos[2]};
		*frontCoords = {roboPos[1],roboPos[2]-1};
		*rightCoords = {roboPos[1]-1, roboPos[2]}
	}
}

//"Floods" the map to find the closest decision point with open ('o') adjacent boxes
void goTo(int coords[2])
{
	//char *floodMapPtr[15][15];
	int floodMapFirstCol;
	char floodMap[15][15];
	int oCoords[2];
	
	//finds where to cut off the big map
	for (int i = 1; i<16; i++)
	{
		for (int j = 1; j<16; j++)
		{
			if (mapArray[i][j] != 'u' || mapArray[i][j] != 'w')
			{
				floodMapFirstCol = j;
				break;
			}
		}
	}
	
	//makes the flooding-map as a copy of a part of the big map
	for (int i = 1; i < 16; i++)
	{
		for (int j = floodMapFirstCol; j < floodMapFirstCol + 15; j++)
		{
			floodMap[i][j] =  mapArray[i][j];
		}
	}
	
	//floods map until an open intersection is found
	int foundO = 0;
	int floodingRound = 1;
	map[roboPos] = 0;
	
	//flooding
	while(!foundO)
	{
		for(int i = 0; i<15; i++)
		{
			for (int j = 0; j<15; j++)
			{
				//checks if box was flooded last round
				if (map[i][j] == floodingRound - 1)
				{
					//floods adjacent boxes
					if ((i+1 < 15) && (map[i+1][j] > floodingRound) && (map[i+1][j] < 97 /*97 because that's where the lower case letters begin in ASCII*/))
					{
						map[i+1][j] = floodingRound;
					}
					if ((i-1 > -1) && (map[i+1][j] > floodingRound) && (map[i-1][j] < 97))
					{
						map[i-1][j] = floodingRound;
					}
					if ((j+1 < 15) && (map[i][j+1] > floodingRound) && (map[i][j+1] < 97))
					{
						map[i][j+1] = floodingRound;
					}
					if ((j-1 > -1) && (map[i][j-1] > floodingRound) && (map[i][j-1] < 97))
					{
						map[i][j-1] = floodingRound;
					}
				}
				else if (map[i][j] == 'o')
				{
					oCoords = map[i][j];
					foundO = 1;
				}
				++floodingRound;
			}
		}
	}
	//decides route to found intersection
	//findRouteToCoords(oCoords);
	if (foundO)
	{
		int route[floodingRound][2];
		route[floodingRound-1] = oCoords;
		while(floodingRound > 1)
		{
			if ((route[floodingRound-1][1]+1 < 15) && (map[route[floodingRound-1][0]+1][route[floodingRound-1][1]] < floodingRound))
			{
				route[floodingRound-2] = map[route[floodingRound-1][0]+1][route[floodingRound-1][1]];
			}
			else if ((route[floodingRound-1][1]-1 > 0) && (map[route[floodingRound-1][0]-1][route[floodingRound-1][1]] < floodingRound))
			{
				route[floodingRound-2] = map[route[floodingRound-1][0]-1][route[floodingRound-1][1]];
			}
			else if ((route[floodingRound-1][0]+1 < 15) && (map[route[floodingRound-1][0]][route[floodingRound-1][1]+1] < floodingRound))
			{
				route[floodingRound-2] = map[route[floodingRound-1][0]][route[floodingRound-1][1]+1];
			}
			else if ((route[floodingRound-1][0]-1 > 0) && (map[route[floodingRound-1][0]][route[floodingRound-1][1]-1] < floodingRound))
			{
				route[floodingRound-2] = map[route[floodingRound-1][0]][route[floodingRound-1][1]-1];
			}
			else
			{
				//If we end up here, something fucked up happened, lol.
			}
			--floodingRound;
		}
	}
	//TODO take robot to found point via decided route
	for (int i = 0; i < (sizeof(route) / sizeof(route[0]); i++)
	{
		sendMap();
		sendSensorData();
		
	}
}

//Decision maker in an intersection or a turn
void controlDecision(){
	//Update map, this is a decision node
	TWITransmitData('b');
	mapArray[roboPos[1]][roboPos[2]] = 'd';
	int tmpLeftCoords[2];
	int tmpFrontCoords[2];
	int tmpRightCoords[2];
	findAdjCoords(&tmpLeftCoords, &tmpFrontCoords, &tmpRightCoords);
	
	int leftFree = leftIsFree(tmpLeftCoords);
	int rightFree = rightIsFree(tmpRightCoords);
	int frontFree = frontIsFree(tmpFrontCoords);
	
	if (leftFree )
	{
		turnLeft();
		goForward();
	}
	else if (frontFree)
	{
		goForward();
	}
	else if (rightFree)
	{
		turnRight();
		goForward();
	}
	else
	{
		TWITransmitData('S');
		//int goToCoords[2] = findClosestOpenIntersect();
		//goTo(goToCoords);
	}
	mapArray[roboPos] = 'c';
	refDist = 0;
}

//Checks if map needs update
void check_dist(){
	float numOfWheelTurns = 0;
	
	numOfWheelTurns = (float) Photo_distance / numOfWheelSectors;
	traveledDistTot = 2*3.14*wheelRad*numOfWheelTurns; // Total distance in cm
	if (traveledDistTot - refDist > 40)
	{
		//Update map
		mapArray[roboPos[1]][roboPos[2]] = 'c';
		if (colDir == 0)
		{
			mapArray[roboPos[1]][roboPos[2]+1] = 'w';
			mapArray[roboPos[1]][roboPos[2]-1] = 'w';
		}
		else
		{
			mapArray[roboPos[1]+1][roboPos[2]] = 'w';
			mapArray[roboPos[1]-1][roboPos[2]] = 'w';
		}
		
		//Update robot position
		roboPos[1] = roboPos[1] + colDir;
		roboPos[2] = roboPos[2] + rowDir;
		
		refDist = traveledDistTot;
	}
}


int main(void)
{
	DDRA = 0xFF;
	TWIInit();
	init_bluetooth();
	mapInit();
	
	while (1)
	{
		sendSensorData();
		sendMap();
		//check if autonomous mode
		if (!(PINB & (1<<PINB0)))
		{
			//_delay_ms(100);
			TWITransmitData('p');
			check_dist();

			if ((IR_sens_left > 0x085C) || (IR_sens_right > 0x085C))
			{
				TWITransmitData('S');
				controlDecision();
			}
		}
		//remote control-mode
		else
		{
			//Nothing happens here
		}
	}
}
