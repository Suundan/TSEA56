/*
 * SENS_.c
 *
 * Created: 4/12/2016 8:28:57 AM
 *  Author: marha996
 */ 

#define F_CPU 1842000UL
#include <avr/io.h>
#include <avr/delay.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include <util/twi.h>

uint16_t US_sens_front_left = 0x0;
uint16_t US_pre_sens_front_left = 0x0;
uint16_t US_sens_back_left = 0x0;
uint16_t US_pre_sens_back_left = 0x0;
uint16_t US_sens_right = 0x0;
uint16_t US_pre_sens_right = 0x0;
uint8_t Gyro_sens = 0x0;
uint16_t distance_photo = 0x00;
unsigned int black_white_check= 0;
uint16_t photo_value = 0x0;

//Initierar bussen
void TWIInit(void) {
	
	//Globalt avbrott aktiverat
	sei();
	
	//Sätter SCL hastighet
	TWSR = (0<<TWPS0)|(0<<TWPS1) ; //Sätter prescaler värdet till 1
	TWBR = 0x0C;  //Sätter Bit rate registry till 12
	
	//Aktiverar bussen, aktiverar ackbit, aktiverar avbrott
	TWCR = (1<<TWEN)|(1<<TWEA)|(1<<TWIE);
	
	//Slavadresser (sista ska vara ett för att enabla general call)
	//Kommmudul: 0x11
	//Sensormodul: 0x21
	//Styrmodul: 0x41
	
	TWAR = 0x21;
}

void GyroInit(void) {
	ADMUX = 0x60;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A0 as input
	ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
	
}
void PhotoInit(void){
		ADMUX = 0x67;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A7 as input
		ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
}
//Skickar startbit
void TWIStart(void) {
	TWCR = (1<<TWSTA)|(1<<TWINT)|(0<<TWIE)|(1<<TWEN); //Skickar startbit, sätter avbrottsflaggan, avaktiverar avbrott, aktiverar bussen
	while (!(TWCR & (1<<TWINT))); //Väntar på att start-signalen ska skickas iväg ifall bussen är upptagen t.ex.
	
	//Behöver ej kolla 0x08 eller 0x10, startbit eller repeterad startbit
}

//Skickar stoppbit
void TWIStop(void) {
	TWCR = (1<<TWSTO)|(1<<TWINT)|(1<<TWIE)|(1<<TWEN)|(1<<TWEA); //Skickar stoppbit, sätter avbrottsflaggan, aktiverar avbrott, aktviverar bussen, aktviterar ackbit
}

//Skickar adress + data
void TWITransmitData(uint16_t data1, uint16_t data2, uint8_t data3, uint16_t data4) {
	
	TWIStart();

	//Skicka SLA + W, adress 00 för att det är general call (till alla slaves)
	TWISend(0x00);
	
	//Arbitration lost, borde dock aldrig hamna här inne?!
	if ((TWSR & 0xF8) == 0x38) {
		TWIStop();
		return;
	}
	//Om inte adress mottagen och inte "not ack" mottagen
	if ((TWSR & 0xF8) == 0x20) {	
		TWIStop();
		return;
	}

	//Skickar sensormodulens adress
	TWISend(0x20);
	
	//Send MSB data1
	uint8_t newData = data1 >> 8;
	TWISend(newData);
	
	//Send LSB data1
	newData = data1 & 0xFF;
	TWISend(newData);
	
	//Send MSB data2
	newData = data2 >> 8;
	TWISend(newData);
	
	//Send LSB data2
	newData = data2 & 0xFF;
	TWISend(newData);
	
	TWISend(data3);
	
	//Send MSB data4
	newData = data4 >> 8;
	TWISend(newData);
	
	//Send LSB data4
	newData = data4 & 0xFF;
	TWISend(newData);
	
	TWIStop();
}

//Skickar data
void TWISend(uint8_t data) {
	TWDR = data;
	
	TWCR = (0<<TWSTA)|(1<<TWINT)|(1<<TWEN); //Avaktiverar startflaggan och avbrottsflaggan, avktiverar bussen
	
	while (!(TWCR & (1<<TWINT))); //Väntar på ackbit
	
	//Om inte adress mottagen och inte "not ack" mottagen
	if ((TWSR & 0xF8) == 0x30) {
		//very bad....
	}
}

void readFromSensFront(void) {
	
	// send pulse to US-sensor two, back left
	PORTA = (1<<PORTA1); // Sätter PA1 till hög under bestämd tid
	_delay_us(40);
	PORTA = (0<<PORTA1);// Sätter PA1 till låg och startar mätningen
	
	//wait for us-sensor to start measuring
	while(!(PINA & (1<<PORTA2)));

	//Start counter
	TCCR1B =(1<<CS10);
	
	//wait for final value from us-sensor
	while(PINA & (1<<PORTA2));

	//Stops counter
	TCCR1B = (0<<CS10);
	
	US_pre_sens_front_left = US_sens_front_left;
	
	//Read counter
	US_sens_front_left = TCNT1;
	
	//reset counter
	TCNT1 = 0x0;
}

void readFromSensBack(void) {
	
	// send pulse to US-sensor two, back left
	PORTA = (1<<PORTA3); // Sätter PA1 till hög under bestämd tid
	_delay_us(40);
	PORTA = (0<<PORTA3);// Sätter PA1 till låg och startar mätningen
	
	//wait for us-sensor to start measuring
	while(!(PINA & (1<<PORTA4)));

	//Start counter
	TCCR1B =(1<<CS10);
	
	//wait for final value from us-sensor
	while(PINA & (1<<PORTA4));

	//Stops counter
	TCCR1B = (0<<CS10);
	
	US_pre_sens_back_left = US_sens_back_left;
	
	//Read counter
	US_sens_back_left = TCNT1;
	
	//reset counter
	TCNT1 = 0x0;
}

void readFromSensRight(void) {
	
	// send pulse to US-sensor three, front right
	PORTB = (1<<PORTB0); // Sätter PB0 till hög under bestämd tid
	_delay_us(40);
	PORTB = (0<<PORTB0);// Sätter PA1 till låg och startar mätningen
	
	//wait for us-sensor to start measuring
	while(!(PINB & (1<<PORTB1)));

	//Start counter
	TCCR1B =(1<<CS10);
	
	//wait for final value from us-sensor
	while(PINB & (1<<PORTB1));

	//Stops counter
	TCCR1B = (0<<CS10);
	
	US_pre_sens_right = US_sens_right;
	
	//Read counter
	US_sens_right = TCNT1;
	
	//reset counter
	TCNT1 = 0x0;
}

void readFromGyro(void)
{
	GyroInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	Gyro_sens = ADCH;
	
}
void readFromPhoto(void)
{
	PhotoInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));//wait for conversion complete
	
	photo_value = ADCH;
		if(black_white_check ==1){//if black before, check if white now, if true ++distance
			if(ADCH > 0xC8){
				++distance_photo;
				black_white_check = 0;
			}
			else{
				return;
			}
		}else{
			if(ADCH < 0x64){//if white before, check if black now, if true ++distance
				++distance_photo;
				black_white_check = 1;
			}
			else{
				return;
			}
		}

}

int main(void)
{
	//Init of sensorreading
    DDRA = (1 << PORTA1)|(1 << PORTA3); //PA1 and PA3 to out, PA0 in
	DDRB = (1<< PORTB0);
	TWIInit();
	
	//GyroInit();
	unsigned int loop= 0;
	
    while (1) 
    {
		if(!loop)
		{
			//read front left
			readFromSensFront();
			loop = 1;
		}
		else
		{
			//read back left
			readFromSensBack();
			loop = 0;
		}
		readFromGyro();
		readFromPhoto();
		
		if (loop)
		{
			readFromSensRight();
		}
		
		uint16_t US_back_left = 0x0;
		uint16_t US_front_left = 0x0;
		uint16_t US_right = 0x0;
		
		//Back left, if difference between new and old is large send out old value again, else send new
		if (abs(US_pre_sens_back_left-US_sens_back_left) > US_pre_sens_back_left*0.2) 
		{
			US_back_left = US_pre_sens_back_left;
		} 
		else
		{
			US_back_left = US_sens_back_left;
		}
		
		//Front left, if difference between new and old is large send out old value again, lese send new
		if (abs(US_pre_sens_front_left-US_sens_front_left) > US_pre_sens_front_left*0.2)
		{
			US_front_left = US_pre_sens_front_left;
		}
		else
		{
			US_front_left = US_sens_front_left;
		}
		
		//Front right, if difference between new and old is large send out old value again, lese send new
		if (abs(US_pre_sens_right-US_sens_right) > US_pre_sens_right*0.2)
		{
			US_right = US_pre_sens_right;
		}
		else
		{
			US_right = US_sens_right;
		}
		
		TWITransmitData(US_front_left, US_back_left, US_right, Gyro_sens, distance_photo);
		
	}
}
