/*
 * SENS_.c
 *
 * Created: 4/12/2016 8:28:57 AM
 *  Author: marha996
 */ 

#define F_CPU 1842000UL
#include <avr/io.h>
#include <avr/delay.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include <util/twi.h>

uint16_t US_sens_front_left = 0x0;
uint16_t US_pre_sens_front_left = 0x0;
uint16_t US_sens_back_left = 0x0;
uint16_t US_pre_sens_back_left = 0x0;
uint16_t US_sens_right = 0x0;
uint16_t US_pre_sens_right = 0x0;
uint8_t IR_sens_front = 0x0;
uint8_t IR_pre_sens_front = 0x0;
uint8_t IR_sens_left = 0x0;
uint8_t IR_pre_sens_left = 0x0;
uint8_t IR_sens_right = 0x0;
uint8_t IR_pre_sens_right = 0x0;
uint8_t Gyro_sens = 0x0;
uint16_t distance_photo = 0x00;
unsigned int black_white_check= 0;
uint16_t photo_value = 0x0;
uint8_t ir_detected = 0x00;
//Initierar bussen
void TWIInit(void) {
	
	//Globalt avbrott aktiverat
	sei();
	
	//Sätter SCL hastighet
	TWSR = (0<<TWPS0)|(0<<TWPS1) ; //Sätter prescaler värdet till 1
	TWBR = 0x0C;  //Sätter Bit rate registry till 12
	
	//Aktiverar bussen, aktiverar ackbit, aktiverar avbrott
	TWCR = (1<<TWEN)|(1<<TWEA)|(1<<TWIE);
	
	//Slavadresser (sista ska vara ett för att enabla general call)
	//Kommmudul: 0x10
	//Sensormodul: 0x20
	//Styrmodul: 0x40
	
	TWAR = 0x20;
}

void GyroInit(void) {
	ADMUX = 0x60;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A0 as input
	ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
	
}

void IRDistInit(void) {
	ADMUX = 0x66;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A6 as input
	ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
	
}

void IRLeftInit(void)
{
	ADMUX = 0x65;
	ADCSRA = 0x83;
}

void IRRightInit(void)
{
	ADMUX = 0x61;
	ADCSRA = 0x83;
}

void PhotoInit(void){
		ADMUX = 0x67;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A7 as input
		ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
}
//Skickar startbit
void TWIStart(void) {
	TWCR = (1<<TWSTA)|(1<<TWINT)|(0<<TWIE)|(1<<TWEN); //Skickar startbit, sätter avbrottsflaggan, avaktiverar avbrott, aktiverar bussen
	while (!(TWCR & (1<<TWINT))); //Väntar på att start-signalen ska skickas iväg ifall bussen är upptagen t.ex.
	
	//Behöver ej kolla 0x08 eller 0x10, startbit eller repeterad startbit
}

//Skickar stoppbit
void TWIStop(void) {
	TWCR = (1<<TWSTO)|(1<<TWINT)|(1<<TWIE)|(1<<TWEN)|(1<<TWEA); //Skickar stoppbit, sätter avbrottsflaggan, aktiverar avbrott, aktviverar bussen, aktviterar ackbit
}

//Skickar adress + data
void TWITransmitToComm(uint16_t data1, uint16_t data2, uint8_t data3, uint8_t data4, uint8_t data5, uint8_t data6, uint16_t data7, uint8_t data8) {
	                   
	TWIStart();

	//Skicka SLA + W, adress 00 för att det är general call (till alla slaves)
	TWISend(0x10);
	
	//Arbitration lost, borde dock aldrig hamna här inne?!
	if ((TWSR & 0xF8) == 0x38) {
		TWIStop();
		return;
	}
	//Om inte adress mottagen och inte "not ack" mottagen
	if ((TWSR & 0xF8) == 0x20) {	
		TWIStop();
		return;
	}

	//Skickar sensormodulens adress
	TWISend(0x20);
	
	if ((TWSR & 0xF8) == 0x30) {
		TWIStop();
		return;
	}
	
	//Send MSB data1
	uint8_t newData = data1 >> 8;
	TWISend(newData);
	
	//Send LSB data1
	newData = data1 & 0xFF;
	TWISend(newData);
	
	//Send MSB data2
	newData = data2 >> 8;
	TWISend(newData);
	
	//Send LSB data2
	newData = data2 & 0xFF;
	TWISend(newData);

	//Send data3
	TWISend(data3);
	
	//Send data4
	TWISend(data4);
	//Send data5
	TWISend(data5);
	//Send data6
	TWISend(data6);
	
	//Send MSB data7
	newData = data7 >> 8;
	TWISend(newData);
	
	//Send LSB data7
	newData = data7 & 0xFF;
	TWISend(newData);
	
	//Send LSB data8
	TWISend(data8);
	
	TWIStop();
}

void TWITransmitToControl(uint16_t data1, uint16_t data2, uint8_t data3, uint8_t data4, uint8_t data5, uint8_t data6, uint16_t data7, uint8_t data8) {
	
	TWIStart();

	//Skicka SLA + W, adress 00 för att det är general call (till alla slaves)
	TWISend(0x40);
	
	//Arbitration lost, borde dock aldrig hamna här inne?!
	if ((TWSR & 0xF8) == 0x38) {
		TWIStop();
		return;
	}
	//Om inte adress mottagen och inte "not ack" mottagen
	if ((TWSR & 0xF8) == 0x20) {
		TWIStop();
		return;
	}

	//Skickar sensormodulens adress
	TWISend(0x20);
	
	//Send MSB data1
	uint8_t newData = data1 >> 8;
	TWISend(newData);
	
	//Send LSB data1
	newData = data1 & 0xFF;
	TWISend(newData);
	
	//Send MSB data2
	newData = data2 >> 8;
	TWISend(newData);
	
	//Send LSB data2
	newData = data2 & 0xFF;
	TWISend(newData);

	//Send data3
	TWISend(data3);
	
	//Send data4
	TWISend(data4);
	//Send data5
	TWISend(data5);
	//Send data6
	TWISend(data6);
	
	//Send MSB data7
	newData = data7 >> 8;
	TWISend(newData);
	
	//Send LSB data7
	newData = data7 & 0xFF;
	TWISend(newData);
	
	//Send LSB data8
	TWISend(data8);
	
	TWIStop();
}


//Skickar data
void TWISend(uint8_t data) {
	TWDR = data;
	
	TWCR = (0<<TWSTA)|(1<<TWINT)|(1<<TWEN); //Avaktiverar startflaggan och avbrottsflaggan, avktiverar bussen
	
	while (!(TWCR & (1<<TWINT))); //Väntar på ackbit
}

void readFromSensFront(void) {
	
	// send pulse to US-sensor two, back left
	PORTB = (1<<PORTB3); // Sätter PA1 till hög under bestämd tid
	_delay_us(40);
	PORTB = (0<<PORTB3);// Sätter PA1 till låg och startar mätningen
	
	int i = 0;
	
	//wait for us-sensor to start measuring
	while(!(PINA & (1<<PORTA2)))
	{
		i++;
		if (i >10000){
			return;
		}
	}

	//Start counter
	TCCR1B =(1<<CS10);
	i = 0;
	//wait for final value from us-sensor
	while(PINA & (1<<PORTA2))
	{
		i++;
		if (i > 66000)
		{
			return;
		}
	}

	//Stops counter
	TCCR1B = (0<<CS10);
	
	US_pre_sens_front_left = US_sens_front_left;
	
	//Read counter
	US_sens_front_left = TCNT1;
	
	//reset counter
	TCNT1 = 0x0;
}

void readFromSensBack(void) {
	
	// send pulse to US-sensor two, back left
	PORTA = (1<<PORTA3); // Sätter PA1 till hög under bestämd tid
	_delay_us(40);
	PORTA = (0<<PORTA3);// Sätter PA1 till låg och startar mätningen
	int i = 0;
	//wait for us-sensor to start measuring
	while(!(PINA & (1<<PORTA4)))
	{
		i++;
		if (i >10000)
		{
			return;
		}
	}

	//Start counter
	TCCR1B =(1<<CS10);
	
	i = 0;
	
	//wait for final value from us-sensor
	while(PINA & (1<<PORTA4))
		{
			i++;
			if (i > 66000)
			{
				return;
			}
		}

	//Stops counter
	TCCR1B = (0<<CS10);
	
	US_pre_sens_back_left = US_sens_back_left;
	
	//Read counter
	US_sens_back_left = TCNT1;
	
	//reset counter
	TCNT1 = 0x0;
}
void readFromGyro(void)
{
	GyroInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	Gyro_sens = ADCH;
	
}

void readFromIRDistance(void)
{
	IRDistInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_pre_sens_front = IR_sens_front;
	
	IR_sens_front = ADCH;
	
}

void readFromIRLeft(void)
{
	IRLeftInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_pre_sens_left = IR_sens_left;
	
	IR_sens_left = ADCH;
	
}

void readFromIRRight(void)
{
	IRRightInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_pre_sens_right = IR_sens_right;
	
	IR_sens_right = ADCH;
	
}

void readFromPhoto(void)
{
	PhotoInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));//wait for conversion complete
	
	photo_value = ADCH;
		if(black_white_check ==1){//if black before, check if white now, if true ++distance
			if(ADCH > 0xC8){
				++distance_photo;
				black_white_check = 0;
			}
			else{
				return;
			}
		}else{
			if(ADCH < 0x64){//if white before, check if black now, if true ++distance
				++distance_photo;
				black_white_check = 1;
			}
			else{
				return;
			}
		}

}

uint16_t checkIRValue(void)
{	
	TCCR1B =(1<<CS10);
		
	while(!(PINB & (1<<PINB2)));
		
	TCCR1B = (0<<CS10);
		
	uint16_t count = TCNT1;
	
	TCNT1 = 0x0;
	
	return count;
}

int checkIRPuls(void)
{
	//wait for a zero
	while(PINB & (1<<PINB2));
	
	//check again
	uint16_t count = checkIRValue();
	
	if (abs(count-2000) < 600)
	{
		return 1;
	}
	else
	{
		return 0;
	}
	
}

void read_IR(void){
	
	uint16_t count = checkIRValue();
	
	if (count > 3000)
	{
		if(!checkIRPuls())
		{
			ir_detected = 0x55;
			return;
		}
		if(!checkIRPuls())
		{
			ir_detected = 0x55;
			return;
		}
		if(!checkIRPuls())
		{
			ir_detected = 0x55;
			return;
		}
		
		//OK VALUE, TARGET DETECTED
		ir_detected = 0xFF;
		return;
	}
	else
	{
		TCCR1B =(1<<CS10);
		while (PINB & (1<<PINB2))
		{
			if(TCNT1 > 20000)
			{
				TCCR1B = (0<<CS10);
				TCNT1 = 0x0;
				return;
			}
		}
		read_IR();
		return;
	}	
}

int main(void)
{
	//Init of sensorreading
    DDRA = (1 << PORTA3); //PB3 and PA3 to out to US-sensors,
	DDRB = (1 << PORTB3);
	TWIInit();
	
	//GyroInit();
	unsigned int loop= 0;
	int per_fecht = 0;
    while (1) 
    {
		
		per_fecht++;
		if (per_fecht > 50)
		{
			ir_detected = 0x0;
			per_fecht = 0;
		}
		
		if(!(PINB & (1<<PINB2)))
		{
			read_IR();	
		}
		
		if(!loop)
		{
			//read front left
			readFromSensFront();
			loop = 1;
		}
		else
		{
			//read back left
			readFromSensBack();
			loop = 0;
		}
		
		readFromGyro();
		readFromIRLeft();
		readFromPhoto();
		
		if (loop)
		{
			readFromIRRight();
		}
		else
		{
			readFromIRDistance();
		}

		uint16_t US_back_left = 0x0;
		uint16_t US_front_left = 0x0;
		//uint16_t US_right = 0x0;
		uint8_t IR_front = 0x0;
		uint8_t IR_right = 0x0;
		uint8_t IR_left = 0x0;

		//Back left, if difference between new and old is large send out old value again, else send new
		if (abs(US_pre_sens_back_left-US_sens_back_left) > US_pre_sens_back_left*0.2) 
		{
			US_back_left = US_pre_sens_back_left;
		} 
		else
		{
			US_back_left = US_sens_back_left;
		}
		
		//Front left, if difference between new and old is large send out old value again, lese send new
		if (abs(US_pre_sens_front_left-US_sens_front_left) > US_pre_sens_front_left*0.2)
		{
			US_front_left = US_pre_sens_front_left;
		}
		else
		{
			US_front_left = US_sens_front_left;
		}
		
		
		//Front, if difference between new and old is large send out old value again, else send new
		if (abs(IR_pre_sens_front - IR_sens_front) > IR_pre_sens_front*0.2)
		{
			IR_front = IR_pre_sens_front;
		}
		else
		{
			IR_front = IR_sens_front;
		}
		
		//Right, if difference between new and old is large send out old value again, else send new
		if (abs(IR_pre_sens_right - IR_sens_right) > IR_pre_sens_right*0.2)
		{
			IR_right = IR_pre_sens_right;
		}
		else
		{
			IR_right = IR_sens_right;
		}
		
		//Left, if difference between new and old is large send out old value again, else send new
		if (abs(IR_pre_sens_left - IR_sens_left) > IR_pre_sens_left*0.2)
		{
			IR_left = IR_pre_sens_left;
		}
		else
		{
			IR_left = IR_sens_left;
		}
		
		TWITransmitToComm(US_front_left, US_back_left, IR_sens_left, IR_sens_right, IR_front, Gyro_sens, distance_photo, ir_detected);
		TWITransmitToControl(US_front_left, US_back_left, IR_sens_left, IR_sens_right, IR_front, Gyro_sens, distance_photo, ir_detected);
		
	}
}
