/*
 * STYR.c
 *
 * Created: 4/14/2016 2:32:45 PM
 *  Author: marha996
 */ 

 #define F_CPU 1842000UL
 #include <avr/io.h>
 #include <avr/delay.h>
 #include <util/twi.h>
 #include <avr/interrupt.h>
 
 //uint8_t current_command = 01010011; //Börjar med S
 unsigned int test = 0;
 
 volatile uint8_t kommData = 0b01010011;
 volatile uint16_t US_sens_front_left = 0x0;
 volatile uint16_t US_sens_back_left = 0x0;
 //volatile uint16_t US_sens_right = 0x0;
 volatile uint8_t IR_sens_left = 0x0;
 volatile uint8_t  IR_sens_right = 0x0;
 volatile uint8_t IR_sens_front = 0x0;
 volatile uint8_t Gyro_sens = 0x0;
 volatile uint16_t Photo_distance= 0x0;
 volatile uint16_t ir_detected = 0x0;
 uint16_t speedPD = 0x0FF;
 uint16_t speed = 0x1FF;
 
  //Avbrottsvektor
  ISR(TWI_vect){
	  
	  //Rätt adress mottagen, ackbit skickad
	  if ((TWSR & 0xF8) == 0x60 || (TWSR & 0xF8) == 0x70) {
		  
		  TWCR = (0<<TWIE)|(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
		  
		  while(!(TWCR & (1<<TWINT))); //Väntar på data
		  
		  //Data inte mottagen, ackbit inte skickad
		  if (!((TWSR & 0xF8) == 0x80 || (TWSR & 0xF8) == 0x90)) {
			  while(1){};
		  }
		  //Kommodulen skickar till oss
		  if (TWDR == 0x10) {
			  TWIRecieveFromCom();
			  return;
		  }
		  
		  if (TWDR == 0x20) {
			  TWIRecieveFromSens();
			  return;
		  }
	  }
  }
  
  //Initierar bussen
  void TWIInit(void) {
	  
	  //Globalt avbrott aktviverat
	  sei();
	  
	  //Sätter SCL hastigheten
	  TWSR = (0<<TWPS0)|(0<<TWPS1) ; //Sätter prescaler värdet till 1
	  TWBR = 0x0C; //Sätter bit rate registry till 12
	  
	  TWCR = (1<<TWEN)|(1<<TWEA)|(1<<TWIE);
	  
	  //Slavadresser (sista ska vara ett för att enabla general call)
	  //Kommmudul: 0x11
	  //Sensormodul: 0x21
	  //Styrmodul: 0x41
	  
	  TWAR = 0x41;
  }
  
  void init_pwm()
   {
	   DDRD = 0b00110011; // PD0, PD1 Utångar, PD4,PD5 utgångar (enable OCR1A/B)
	   OCR1A = 0x0;
	   OCR1B = 0x0;
	   PORTD = (1<<PORTD0)|(0<<PORTD1); // DIR_RIGHT Direction framåt, DIR_LEFT framåt
	   TCCR1A |= (1<<COM1A1)| (0<<COM1A0)|(1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(1<<WGM11); // Sätter den i fast PWM-mode 10 bit.
	   TCCR1B |= (0<<WGM13)|(1<<WGM12)|(1<<CS10)|(0<<CS12); // Noninverted med ingen prescaled klocka.
   }
   
  void init_pwm_claw(void)
    {
	    OCR0 = 0x1A;
	    TCCR0 = (1<<WGM01)|(1<<WGM00)|(1<<COM01)|(1<<CS01)|(1<<CS00);
	    DDRB = (1<<PORTB3);
	    
	    OCR2 = 0x3A;
	    TCCR2 = (1<<WGM21)|(1<<WGM20)|(1<<COM21)|(1<<CS21)|(1<<CS20);
	    DDRD |= (1<<PORTD7);
    }
  
 //Ta emot data från Kommodulen
 void TWIRecieveFromCom() {
 	
 	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 	
 	while(!(TWCR & (1<<TWINT))); //Vänta på data
 	
 	//Data inte mottagen, ackbit inte skickad
 	if ((TWSR & 0xF8) != 0x80) {
 		while(1){};
 	}
 	
 	kommData = TWDR;
 
 	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 	
 	while(!(TWCR & (1<<TWINT))); //Väntar på stoppbit
 	
 	TWCR = (1<<TWIE)|(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 }
 
uint16_t Recieve16Data(void) {
	 TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA); //Sätter avbrottsflaggan, aktiverar bussen, aktiverar ackflaggan
	 
	 while(!(TWCR & (1<<TWINT))); //Vänta på data
	 
	 //Data inte mottagen och ackbit inte mottagen
	 if ((TWSR & 0xF8) != 0x90) {
		 while(1){};
	 }

	 uint16_t data_16 = (TWDR << 8);
	 
	 TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA); //Sätter avbrottsflaggan, aktiverar bussen, aktiverar ackflaggan
	 
	 while(!(TWCR & (1<<TWINT))); //Vänta på data
	 
	 //Data inte mottagen och ackbit inte mottagen
	 if ((TWSR & 0xF8) != 0x90) {
		 while(1){};
	 }
	 
	 data_16 |= TWDR;
	 return data_16;
}

uint8_t Recieve8Data(void) {
	
	//Ready to receive next data
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
	
	//Wait for data
	while(!(TWCR & (1<<TWINT)));
	
	// if "not ack" received, do something
	if ((TWSR & 0xF8) != 0x90);

	return TWDR;
}
 
 void TWIRecieveFromSens(void) {
 
 	US_sens_front_left = Recieve16Data();
	US_sens_back_left = Recieve16Data();
	IR_sens_left = Recieve8Data();
	IR_sens_right = Recieve8Data();
	IR_sens_front = Recieve8Data();
	Gyro_sens = Recieve8Data();
	Photo_distance = Recieve16Data();
	ir_detected = Recieve8Data();
	 
 	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 	
 	while(!(TWCR & (1<<TWINT))); //Väntar på stoppbit
 	
 	//Om inte det är en stoppbit
 	if ((TWSR & 0xF8) != 0xA0) {
 		while(1){};
 	}
 	
 	TWCR = (1<<TWIE)|(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 }
 
 void forward(unsigned int speed_right, unsigned int speed_left)
 {
 	OCR1A = speed_left; // Sätter hastighet på (som andel av 0x03ff)
 	OCR1B = speed_right; // Sätter hastighet på (som andel av 0x03ff)
 	PORTD |= (1<<PORTD0); // DIR_RIGHT Direction framåt
 	PORTD &= ~(1<<PORTD1); // DIR_LEFT framåt
 }
 
 void backward(unsigned int speed_right, unsigned int speed_left)
 {
 	OCR1A = speed_left; // Sätter hastighet på (som andel av 0x03ff)
 	OCR1B = speed_right; // Sätter hastighet på (som andel av 0x03ff)
 	PORTD &= ~(1<<PORTD0); // DIR_RIGHT bakåt
 	PORTD |= (1<<PORTD1); // DIR_LEFT bakåt
 }
 
 void stop()
 {
 	OCR1A = 0x0; // Sätter hastighet noll på
 	OCR1B = 0x0; // Sätter hastighet noll på
 }
 
 void turn_left(unsigned int speed)
 {
 	PORTD &= ~(1<<PORTD0); // DIR_RIGHT bakåt
 	PORTD &= ~(1<<PORTD1); // DIR_LEFT framåt
 	OCR1A = speed;
 	OCR1B = speed;
 }
 
 void rotate_90_left(void){
	 
	 //left-wise (anti-clock) rotation increases gyro
	 PORTD &= ~(1<<PORTD0); // DIR_RIGHT bakåt
	 PORTD &= ~(1<<PORTD1); // DIR_LEFT framåt
	 OCR1A = speed;
	 OCR1B = speed;
	 
	 uint16_t sum_velocity = 0x0;
	 
	 while(sum_velocity < 0xB00)
	 {
		sum_velocity += abs(Gyro_sens - 0xAB);
		_delay_ms(6);
	 }
	 
	 kommData = 'S';
 } 
 
void rotate_90_right(void){
 
 //left-wise (anti-clock) rotation increases gyro
 PORTD |= (1<<PORTD0); // DIR_RIGHT bakåt
 PORTD |= (1<<PORTD1); // DIR_LEFT framåt
 OCR1A = speed;
 OCR1B = speed;
 
 uint16_t sum_velocity = 0x0;
 
 while(sum_velocity < 0x900)
 {
	 sum_velocity += abs(Gyro_sens- 0xAB);
	 _delay_ms(6);
 }
 
 kommData = 'S';	
}
 
void rotate_180(void){
	rotate_90_left();
	rotate_90_left();
}

 void turn_right(unsigned int speed)
 {
 	PORTD |= (1<<PORTD0);
 	PORTD |= (1<<PORTD1);
 	OCR1A = speed;
 	OCR1B = speed;
 }
 
 void lowerClaw(void)
 {
	 //Min 0x20
	 OCR2 = 0x3A;
	 
 }
 
 void higherClaw(void)
 {
	 //Max 0x60
	 OCR2 = 0x60;
	 
 }
 
 void openClaw(void)
 {
	 //Min 0x10
	 OCR0 = 0x1A;
 }
 
 void closeClaw(void)
 {
	 //Max 0x4A
	 OCR0 = 0x4A;
 }
  
 void pd_control(void){
	   
	   uint16_t sens_back_left;
	   uint16_t sens_front_left;
	   int k_p = 35;
	   uint16_t p_term;
	   uint16_t ref_value = 0x0370;
	   uint16_t error = 0x0;
	   
	   uint16_t k_d = 45;
	   uint16_t d_term;
	   
	   uint16_t pd_term;
	   
	   
	   PORTD |= (1<<PORTD0); // DIR_RIGHT Direction framåt
	   PORTD &= ~(1<<PORTD1); // DIR_LEFT framåt
	   OCR1A = speedPD;
	   OCR1B = speedPD;
	   
	   while (1){
		   if(kommData != 'p') return;
		   //Update sensor values
		   sens_front_left = US_sens_front_left;
		   sens_back_left = US_sens_back_left;
		   
		   if (sens_front_left > ref_value) {
			   //to far to the right
			   //increase right speed
			   
			   error = sens_front_left - ref_value;
			   
			   //p-term:
			   p_term = k_p * (error / 100);
			   
			   //d-term:
			   if (sens_front_left > sens_back_left) {
				   //incline from left wall
				   //i.e. increase right speed
				   d_term = k_d * ((sens_front_left - sens_back_left) / 100);
				   pd_term = p_term + d_term;
				   
				   }else{
				   //incline towards left wall
				   //i.e. decrease right speed
				   d_term = k_d * ((sens_back_left - sens_front_left) / 100);
				   if ( d_term > p_term) d_term = p_term;
				   pd_term = p_term - d_term;
			   }
			   
			   if (pd_term > 0x00FF) pd_term = 0x00FF;
			   OCR1B = speedPD - pd_term; //left
			   OCR1A = speedPD + pd_term; //right
			   
			   } else {
			   //to far to the left
			   //increase left speed
			   error = ref_value - sens_front_left;
			   
			   //p-term:
			   p_term = k_p * (error / 100);
			   
			   //d-term:
			   if (sens_front_left > sens_back_left) {
				   //incline away from left wall
				   //i.e. decrease left speed
				   d_term = k_d * ((sens_front_left - sens_back_left) / 100);
				   if ( d_term > p_term) d_term = p_term;
				   pd_term = p_term - d_term;
				   
				   }else{
				   //incline towards left wall
				   //i.e. increase left speed
				   d_term = k_d * ((sens_back_left - sens_front_left) / 100);
				   pd_term = p_term + d_term;
			   }
			   
			   if (pd_term > 0x00FF) pd_term = 0x00FF;
			   OCR1B = speedPD + pd_term; //left
			   OCR1A = speedPD - pd_term; //right
		   }
		   
	   }
   }
   
 void RobotDance(void)
 {
	 forward(0x1FF,0x1FF);
	 _delay_ms(500);
	 stop();
	 rotate_180();
	 forward(0x1FF,0x1FF);
	 _delay_ms(500);
	 stop();
	 rotate_180();
	 higherClaw();
	 _delay_ms(500);
	 closeClaw();
	 _delay_ms(500);
	 openClaw();
	 lowerClaw();
	 _delay_ms(500);
	 closeClaw();
	 _delay_ms(500);
	 openClaw();
	 _delay_ms(500);
	 higherClaw();
	 closeClaw();
	 rotate_180();
	 rotate_180();
	 lowerClaw();
	 _delay_ms(500);
	 closeClaw();
 }
 
 void shortForward(uint16_t i)
 { 
	 uint16_t distance = Photo_distance;
	 forward(speedPD, speedPD);
	
	 while(Photo_distance - distance < i);
	 
	 if ((kommData = 's') || (kommData = 'k')) kommData = 'S';
 }
 
 void turnLeftCorridor(void) {
	 rotate_90_left();
	 shortForward(0x6);
 }
 
 void turnRightCorridor(void) {
	  rotate_90_right();
	  shortForward(0x6);
 }
 
 void straightForward(void) 
 {
	shortForward(0x9);
 }
   
 void manual_mode(void){
	 while (1) {
		 switch(kommData) {
			 case 'S':	//Stopp
			 stop();
			 break;
			 case 'F':	//Framåt
			 forward(0x2AA,0x2AA);
			 break;
			 case 'B':	//Bakåt
			 backward(0x2AA,0x2AA);
			 break;
			 case 'L':	//Vänster
			 turn_left(0x2AA);
			 break;
			 case 'R':	//Höger
			 turn_right(0x2AA);
			 break;
			 case 'E':	//Fram höger
			 forward(0x2AA,0x1AA);
			 break;
			 case 'Q':	//Fram vänster
			 forward(0x1AA,0x2AA);
			 break;
			 case 'p':
			 pd_control();
			 break;
			 case 'v':
			 rotate_90_left();
			 break;
			 case 'r':
			 rotate_90_right();
			 break;
			 case 'u':
			 rotate_180();
			 break;
			 case 'l':
			 lowerClaw();
			 break;
			 case 'h':
			 higherClaw();
			 break;
			 case 'o':
			 openClaw();
			 break;
			 case 'c':
			 closeClaw();
			 break;
			 case 'd':
			 RobotDance();
			 break;
			 case 's':
			 turnLeftCorridor();
			 break;
			 case 'k':
			 turnRightCorridor();
			 break;
			 case 'b':
			 shortForward(0x5);
			 break;
			 case 'z':
			 shortForward(0x6);
			 break;
			 case 'j':
			 straightForward();
			 break;
			 default:
			 stop();
		 }
	 }
 }   
 
 int main(void)
 {
 	init_pwm(); //Sätter grundinställningar för PWM
 	init_pwm_claw();
 	TWIInit(); //Initierar bussen
 	
	manual_mode();

 }
