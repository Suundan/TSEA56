/*
 * SENS_.c
 *
 * Created: 4/12/2016 8:28:57 AM
 *  Author: marha996
 */ 

#define F_CPU 1842000UL
#include <avr/io.h>
#include <avr/delay.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include <util/twi.h>

uint8_t IR_sens_front = 0x1;
uint8_t IR_sens_left = 0x0;
uint8_t IR_sens_left_back = 0x0;
uint8_t IR_sens_right = 0x0;
uint8_t Gyro_sens = 0x0;
uint16_t distance_photo = 0x00;
unsigned int black_white_check= 0;
uint16_t photo_value = 0x0;
uint8_t ir_detected = 0x00;

//Initierar bussen
void TWIInit(void) {
	
	//Globalt avbrott aktiverat
	sei();
	
	//Sätter SCL hastighet
	TWSR = (0<<TWPS0)|(0<<TWPS1) ; //Sätter prescaler värdet till 1
	TWBR = 0x0C;  //Sätter Bit rate registry till 12
	
	//Aktiverar bussen, aktiverar ackbit, aktiverar avbrott
	TWCR = (1<<TWEN)|(1<<TWEA)|(1<<TWIE);
	
	//Slavadresser 
	//Kommmudul: 0x10
	//Sensormodul: 0x20
	//Styrmodul: 0x40
	
	TWAR = 0x20;
}

void GyroInit(void) {
	ADMUX = 0x60;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A0 as input
	ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
	
}

void IRFrontInit(void) {
	ADMUX = 0x63;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A6 as input
	ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
}

void IRLeftFrontInit(void)
{
	ADMUX = 0x62;
	ADCSRA = 0x83;
}

void IRRightInit(void)
{
	ADMUX = 0x61;
	ADCSRA = 0x83;
}

void IRLeftBackInit(void)
{
	ADMUX = 0x65;
	ADCSRA = 0x83;
}

void PhotoInit(void){
	ADMUX = 0x67;		//Leftshift the output from the ad-converter (reads from ADCH) and sets A7 as input
	ADCSRA = 0x83;		//Sets up the ad-converter to enable and prescale with 8
}
//Skickar startbit
void TWIStart(void) {
	TWCR = (1<<TWSTA)|(1<<TWINT)|(0<<TWIE)|(1<<TWEN); //Skickar startbit, sätter avbrottsflaggan, avaktiverar avbrott, aktiverar bussen
	while (!(TWCR & (1<<TWINT))); //Väntar på att start-signalen ska skickas iväg ifall bussen är upptagen t.ex.
}

//Skickar stoppbit
void TWIStop(void) {
	TWCR = (1<<TWSTO)|(1<<TWINT)|(1<<TWIE)|(1<<TWEN)|(1<<TWEA); //Skickar stoppbit, sätter avbrottsflaggan, aktiverar avbrott, aktviverar bussen, aktviterar ackbit
}

//Skickar adress + data
void TWITransmit(uint8_t address, uint8_t data1, uint8_t data2, uint8_t data3, uint8_t data4, uint8_t data5, uint16_t data6, uint8_t data7) {
	
	//Disable interrupts while sending data to bus
	cli();
	
	//Send start condition
	TWIStart();
	
	//Check if start is not sent
	if (((TWSR & 0xF8) != 0x08) && ((TWSR & 0xF8) != 0x10))
	{
		TWIStop();
		sei();
		return;
	}
	
	//Send SLA+W 
	TWISend(address);
	
	//Check if not right
	if((TWSR & 0xF8) != 0x18) {
		
		//Check if arbitration is lost
		if ((TWSR & 0xF8) == 0x38) {
			TWIStop(); //release bus control
			sei();
			return;
		}
		
		//"not ack" received
		if ((TWSR & 0xF8) == 0x20) {
			
			TWIStop(); //release bus control
			sei();
			return;
		}
	}

	//Skickar sensormodulens adress
	TWISend(0x20);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	//Send MSB data1
	TWISend(data1);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	//Send LSB data1
	TWISend(data2);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	TWISend(data3);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	TWISend(data4);

	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	//Send data3
	TWISend(data5);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	//Send MSB data7
	uint8_t newData = data6 >> 8;
	TWISend(newData);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	//Send LSB data7
	newData = data6 & 0xFF;
	TWISend(newData);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
	
	//Send LSB data8
	TWISend(data7);
	
	//Data sent, "ack" not received
	if ((TWSR & 0xF8) != 0x28)
	{
		TWIStop(); //release bus control
		return;
	}
		
	//Send stop condition
	TWIStop();
		
	//Enable interrupts again
	sei();
}

//Skickar data
void TWISend(uint8_t data) {
	TWDR = data;
	
	TWCR = (0<<TWSTA)|(1<<TWINT)|(1<<TWEN); //Avaktiverar startflaggan och avbrottsflaggan, avktiverar bussen
	
	while (!(TWCR & (1<<TWINT))); //Väntar på ackbit
}

void readFromGyro(void)
{
	GyroInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	Gyro_sens = ADCH;
	
}

void readFromIRFront(void)
{
	IRFrontInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_sens_front = ADCH;
	
}

void readFromIRLeft(void)
{
	IRLeftFrontInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_sens_left = ADCH;
	
}

void readFromIRLeftBack(void)
{
	IRLeftBackInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_sens_left_back = ADCH;
	
}

void readFromIRRight(void)
{
	IRRightInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));
	
	IR_sens_right = ADCH;
	
}

void readFromPhoto(void)
{
	PhotoInit();
	
	ADCSRA |= (1<<ADSC);// Start the conversion
	
	while( !(ADCSRA & (1<<ADIF)));//wait for conversion complete
	
	photo_value = ADCH;
		if(black_white_check ==1){//if black before, check if white now, if true ++distance
			if(ADCH > 0xC8){
				++distance_photo;
				black_white_check = 0;
			}
			else{
				return;
			}
		}else{
			if(ADCH < 0x64){//if white before, check if black now, if true ++distance
				++distance_photo;
				black_white_check = 1;
			}
			else{
				return;
			}
		}

}

uint16_t checkIRValue(void)
{	
	TCCR1B =(1<<CS10);
		
	while(!(PINB & (1<<PINB2)));
		
	TCCR1B = (0<<CS10);
		
	uint16_t count = TCNT1;
	
	TCNT1 = 0x0;
	
	return count;
}

int checkIRPuls(void)
{
	//wait for a zero
	while(PINB & (1<<PINB2));
	
	//check again
	uint16_t count = checkIRValue();
	
	if (abs(count-2000) < 600)
	{
		return 1;
	}
	else
	{
		return 0;
	}
	
}

void read_IR(void){
	
	uint16_t count = checkIRValue();
	
	if (count > 3000)
	{
		if(!checkIRPuls())
		{
			ir_detected = 0x55;
			return;
		}
		if(!checkIRPuls())
		{
			ir_detected = 0x55;
			return;
		}
		if(!checkIRPuls())
		{
			ir_detected = 0x55;
			return;
		}
		
		//OK VALUE, TARGET DETECTED
		ir_detected = 0xFF;
		return;
	}
	else
	{
		TCCR1B =(1<<CS10);
		while (PINB & (1<<PINB2))
		{
			if(TCNT1 > 20000)
			{
				TCCR1B = (0<<CS10);
				TCNT1 = 0x0;
				return;
			}
		}
		read_IR();
		return;
	}	
}

int main(void)
{
	TWIInit();
	
	//GyroInit();
	int per_fecht = 0;
    while (1) 
    {
		per_fecht++;
		if (per_fecht > 50)
		{
			ir_detected = 0x0;
			per_fecht = 0;
		}
		
		if(!(PINB & (1<<PINB2)))
		{
			read_IR();	
		}
		
		readFromGyro();
		readFromIRLeft();
		readFromIRLeftBack();
		readFromIRRight();
		readFromIRFront();
		readFromPhoto();
		
		
		TWITransmit(0x10, IR_sens_left, IR_sens_left_back, IR_sens_right, IR_sens_front, Gyro_sens, distance_photo, ir_detected);
		TWITransmit(0x40, IR_sens_left, IR_sens_left_back, IR_sens_right, IR_sens_front, Gyro_sens, distance_photo, ir_detected);
	}
}
